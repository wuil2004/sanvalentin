<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Wuil - Galáctico Pro Elite</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        #ui-container {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; z-index: 100; background: rgba(0,0,0,0.9);
            padding: 40px; border-radius: 20px; border: 2px solid #ff0055;
            box-shadow: 0 0 30px #ff0055; color: white;
        }
        input { padding: 15px; border-radius: 30px; border: 2px solid #ff0055; background: #000; color: #fff; text-align: center; width: 280px; font-size: 1.2rem; outline: none; }
        button { padding: 15px 30px; border-radius: 30px; background: #ff0055; color: #fff; border: none; cursor: pointer; font-weight: bold; margin-top: 20px; transition: 0.3s; }
        button:hover { background: #ff4d88; box-shadow: 0 0 20px #ff0055; }
        #video-container { position: absolute; bottom: 10px; right: 10px; width: 120px; opacity: 0.2; }
        video { width: 100%; transform: scaleX(-1); }
    </style>
</head>
<body>

<div id="ui-container">
    <h1>Efecto Infinito Dinámico</h1>
    <p>Puño: Esfera | OK: Corazón | Paz: Nombre | Palma: Enjambre</p>
    <p><small>(Acerca o aleja la mano para cambiar el tamaño)</small></p>
    <input type="text" id="targetName" placeholder="Escribe un nombre...">
    <br>
    <button onclick="startExperience()">INICIAR MAGIA</button>
</div>

<div id="video-container"><video id="input_video"></video></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
let scene, camera, renderer, particles, geometry, stars, starGeometry;
let petalParticles, petalGeometry;
let pointsCount = 45000;
let petalCount = 400;
let starCount = 3500;
let spherePos = [], heartPos = [], namePos = [], lotusPos = [], lotusColors = [], idlePos = [];
let currentTarget = "idle";
let targetX = 0, targetY = 0, currentScale = 1, rotY = 0, rotX = 0, autoRot = 0, time = 0;
let handVel = 0, lastHandX = 0, lastHandY = 0;
const videoElement = document.getElementById('input_video');

function createCircleTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.3, 'rgba(255,255,255,0.7)');
    gradient.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = gradient; ctx.fillRect(0, 0, 64, 64);
    const texture = new THREE.Texture(canvas); texture.needsUpdate = true; return texture;
}

function initThree() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
    camera.position.z = 850;

    starGeometry = new THREE.BufferGeometry();
    let starPositions = [], starColors = [];
    for (let i = 0; i < starCount; i++) {
        const r_dist = 600 + Math.random() * 4400; 
        const theta = Math.random() * Math.PI * 2, phi = Math.acos(Math.random() * 2 - 1);
        starPositions.push(r_dist * Math.sin(phi) * Math.cos(theta), r_dist * Math.sin(phi) * Math.sin(theta), r_dist * Math.cos(phi));
        const randColor = Math.random();
        if (randColor > 0.8) starColors.push(1, 0.4, 0.7);
        else if (randColor > 0.5) starColors.push(0.4, 0.9, 1);
        else starColors.push(1, 1, 1);
    }
    starGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(starPositions), 3));
    starGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(starColors), 3));
    stars = new THREE.Points(starGeometry, new THREE.PointsMaterial({ size: 7.0, vertexColors: true, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, map: createCircleTexture(), depthWrite: false, sizeAttenuation: true }));
    scene.add(stars);

    for (let i = 0; i < pointsCount; i++) {
        const theta = Math.random() * Math.PI * 2, phi = Math.acos(Math.random() * 2 - 1);
        spherePos.push(220 * Math.sin(phi) * Math.cos(theta), 220 * Math.sin(phi) * Math.sin(theta), 220 * Math.cos(phi));
        idlePos.push((Math.random()-0.5)*1200, (Math.random()-0.5)*1000, (Math.random()-0.5)*1000);
        
        const t = Math.random() * Math.PI * 2, u = Math.random(), stretch = Math.sqrt(u); 
        let hx = 16 * Math.pow(Math.sin(t), 3);
        let hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        heartPos.push(hx * stretch * 18, hy * stretch * 18, (1 - stretch) * 130 * (Math.random() - 0.5) * 2);

        if (i < 30000) { 
            const pNum = Math.floor(i / 500), lay = Math.floor(pNum / 10), ang = (pNum * Math.PI * 2) / 10 + (lay * 0.4), pu = Math.random(), r = pu * 350, width = Math.sin(pu * Math.PI) * 85 * (1 - lay * 0.1); 
            lotusPos.push(r * Math.cos(ang) + (Math.random()-0.5)*2*width*Math.sin(ang), Math.pow(pu, 1.2)*100*(lay*0.25+1)+(Math.random()-0.5)*25, r * Math.sin(ang) - (Math.random()-0.5)*2*width*Math.cos(ang));
            lotusColors.push(0.98, 0.98, 1); 
        } else if (i < 40000) { 
            const a = Math.random() * Math.PI * 2, rr = Math.sqrt(Math.random()) * 520; 
            lotusPos.push(rr * Math.cos(a), -50 + (Math.random()*15), rr * Math.sin(a)); lotusColors.push(0.05, 0.5, 0.15); 
        } else { 
            const a = Math.random() * Math.PI * 2, rr = Math.random() * 90;
            lotusPos.push(rr * Math.cos(a), Math.random() * 60, rr * Math.sin(a)); lotusColors.push(1, 0.8, 0); 
        }
    }

    geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(idlePos), 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(pointsCount * 3), 3));
    particles = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 2.8, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, vertexColors: true }));
    scene.add(particles);

    petalGeometry = new THREE.BufferGeometry();
    let pPositions = [];
    for(let i=0; i<petalCount; i++) pPositions.push((Math.random()-0.5)*1500, 600 + Math.random()*1000, (Math.random()-0.5)*1000);
    petalGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(pPositions), 3));
    petalParticles = new THREE.Points(petalGeometry, new THREE.PointsMaterial({ size: 7, color: 0xff0044, transparent: true, opacity: 0 }));
    scene.add(petalParticles);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
}

function generateNamePoints(name) {
    const canvas = document.createElement('canvas'), ctx = canvas.getContext('2d');
    canvas.width = 1000; canvas.height = 300;
    ctx.fillStyle = "white"; ctx.font = "bold 160px Arial"; ctx.textAlign = "center";
    ctx.fillText(name.toUpperCase(), 500, 180);
    const data = ctx.getImageData(0,0,1000,300).data;
    let pixels = [];
    for (let y=0; y<300; y+=2) for (let x=0; x<1000; x+=2) if (data[(y*1000+x)*4] > 180) pixels.push({x:(x-500)*1.8, y:(150-y)*1.8});
    namePos = []; for (let i=0; i<pointsCount; i++){ const p = pixels[i % pixels.length]; namePos.push(p.x, p.y, (Math.random()-0.5)*20); }
}

function startExperience() {
    const name = document.getElementById('targetName').value;
    if (name) { generateNamePoints(name); document.getElementById('ui-container').style.display = 'none'; camera_mp.start(); }
}

const hands = new Hands({locateFile: (file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({maxNumHands:2, modelComplexity:1, minDetectionConfidence:0.75});

hands.onResults((results)=>{
    if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) { 
        currentTarget = "idle"; 
        rotY = 0; rotX = 0; targetX = 0; targetY = 0; 
        return; 
    }
    const lm = results.multiHandLandmarks[0];
    const currX = lm[9].x, currY = lm[9].y;
    handVel = Math.hypot(currX - lastHandX, currY - lastHandY) * 150;
    lastHandX = currX; lastHandY = currY;

    rotY = (lm[8].x - 0.5) * Math.PI * 2; rotX = (lm[8].y - 0.5) * Math.PI;

    if (results.multiHandLandmarks.length === 2) {
        currentTarget = "lotus";
        const h1 = results.multiHandLandmarks[0][9], h2 = results.multiHandLandmarks[1][9];
        currentScale = Math.max(0.1, Math.hypot(h1.x-h2.x, h1.y-h2.y) * 3.5); 
        targetX = ((h1.x+h2.x)/2 - 0.5)*-1200; targetY = ((h1.y+h2.y)/2 - 0.5)*-1000;
    } else {
        targetX = (lm[9].x - 0.5) * -1200; targetY = (lm[9].y - 0.5) * -1000;
        const d_ok = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
        const peace = (lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[16].y > lm[14].y);
        const open = (lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[16].y < lm[14].y && lm[20].y < lm[18].y);
        const fist = (lm[8].y > lm[6].y && lm[12].y > lm[10].y && lm[16].y > lm[14].y && lm[20].y > lm[18].y);

        // Medir tamaño de la palma para el escalado
        const handSize = Math.hypot(lm[5].x - lm[17].x, lm[5].y - lm[17].y);

        if (fist) {
            currentTarget = "sphere";
            currentScale = THREE.MathUtils.lerp(currentScale, handSize * 15, 0.1); 
        }
        else if (d_ok < 0.05) {
            currentTarget = "heart";
            currentScale = THREE.MathUtils.lerp(currentScale, handSize * 15, 0.1);
        }
        else if (open) currentTarget = "infinity"; 
        else if (peace) currentTarget = "name"; 
        else currentTarget = "idle";
    }
});

const camera_mp = new Camera(videoElement, { onFrame: async ()=>{ await hands.send({image: videoElement}); } });

function animate() {
    requestAnimationFrame(animate); time += 0.05; autoRot += 0.005;
    stars.rotation.y += 0.0006; stars.rotation.z += 0.0003;
    stars.material.opacity = 0.6 + Math.sin(time * 0.8) * 0.3;

    const pos = geometry.attributes.position.array, col = geometry.attributes.color.array;
    
    // Latido base para el corazón
    const heartBeat = Math.pow(Math.sin(time * 3), 4);
    
    let targetArr;
    if(currentTarget === "sphere") targetArr = spherePos;
    else if(currentTarget === "heart") targetArr = heartPos;
    else if(currentTarget === "name") targetArr = namePos;
    else if(currentTarget === "lotus") targetArr = lotusPos;
    else targetArr = idlePos;

    for (let i=0; i<pointsCount; i++){
        const i3 = i*3;
        let tx, ty, tz, c;

        if (currentTarget === "infinity") {
            const speed = (0.02 + (i % 20) * 0.002) * (1 + handVel * 0.1);
            const dist = (80 + (i % 300)) * (1 + handVel * 0.05);
            tx = Math.sin(time * speed + i) * dist;
            ty = Math.cos(time * speed * 0.8 + i) * dist;
            tz = Math.sin(time * speed * 1.2 + i) * dist;
            const colorInterp = Math.min(1, handVel * 0.5);
            c = { r: 0.1 + colorInterp * 0.8, g: 0.9 - colorInterp * 0.7, b: 1 };
        } else if (currentTarget === "idle") {
            tx = targetArr[i3] + Math.sin(time * 0.2 + i) * 10;
            ty = targetArr[i3+1] + Math.cos(time * 0.2 + i) * 10;
            tz = targetArr[i3+2];
            c = {r: 0.3, g: 0.3, b: 0.4};
        } else if (currentTarget === "sphere") {
            const jitter = handVel * 2;
            tx = targetArr[i3] * currentScale + (Math.random()-0.5) * jitter;
            ty = targetArr[i3+1] * currentScale + (Math.random()-0.5) * jitter;
            tz = targetArr[i3+2] * currentScale + (Math.random()-0.5) * jitter;
            const flash = Math.min(1, handVel * 0.3);
            c = {r: 0.2 + flash, g: 0.7 + flash, b: 1};
        } else if (currentTarget === "heart") {
            // El latido se vuelve más fuerte cuando el corazón es más grande
            const beatIntensity = 0.1 + (currentScale * 0.05);
            const dynamicScale = currentScale * (1 + heartBeat * beatIntensity);
            tx = targetArr[i3] * dynamicScale;
            ty = targetArr[i3+1] * dynamicScale;
            tz = targetArr[i3+2] * dynamicScale;
            
            // Color rojo pulsa con el latido
            const pulseColor = 0.6 + heartBeat * 0.4;
            const flash = Math.min(0.2, handVel * 0.2);
            c = {r: pulseColor + flash, g: 0.05 + flash, b: 0.1 + flash};
        } else {
            tx = targetArr[i3]; 
            ty = targetArr[i3+1]; 
            tz = targetArr[i3+2];
            if (currentTarget==="lotus") {
                particles.scale.set(currentScale, currentScale, currentScale);
                c = i < 30000 ? {r:0.98, g:0.98, b:1} : (i < 40000 ? {r:0.05, g:0.5, b:0.15} : {r:1, g:0.8, b:0});
            } else {
                particles.scale.set(1, 1, 1);
                c = currentTarget==="name"? {r:1,g:1,b:1} : {r:0.8, g:0.9, b:1};
            }
        }

        pos[i3] += (tx - pos[i3]) * 0.1; pos[i3+1] += (ty - pos[i3+1]) * 0.1; pos[i3+2] += (tz - pos[i3+2]) * 0.1;
        col[i3] += (c.r - col[i3]) * 0.1; col[i3+1] += (c.g - col[i3+1]) * 0.1; col[i3+2] += (c.b - col[i3+2]) * 0.1;
    }
    geometry.attributes.position.needsUpdate = true; geometry.attributes.color.needsUpdate = true;
    
    petalParticles.material.opacity += (currentTarget === "name" ? 0.8 : -petalParticles.material.opacity) * 0.05;
    const pPos = petalGeometry.attributes.position.array;
    for(let i=0; i<petalCount; i++) {
        const i3 = i*3; pPos[i3+1] -= 2.5; pPos[i3] += Math.sin(time + i) * 1.5;
        if(pPos[i3+1] < -500) { pPos[i3+1] = 700; pPos[i3] = (Math.random()-0.5)*1500; }
    }
    petalGeometry.attributes.position.needsUpdate = true;
    
    particles.rotation.y = rotY + autoRot; particles.rotation.x = rotX;
    
    particles.position.x += (targetX - particles.position.x) * 0.1; particles.position.y += (targetY - particles.position.y) * 0.1;
    renderer.render(scene, camera);
}
initThree(); animate();
window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
</script>
</body>
</html>